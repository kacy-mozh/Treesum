/* 1. Разработать «чистую» функцию treeSum, которая получает массив, элементы которого могут быть числами или снова массивами, и так до любого уровня.
Функция должна рассчитать и вернуть сумму всех числовых элементов массива со всех уровней.
При написании функции не описывать каких-либо вложенных в неё функций.
Проверить работу функции можно на следующем массиве (сумма 50):
[5,7
    [4, [2], 8, [1, 3], 2],
    [9, []],
    1, 8
]


2. Создайте функцию, которая принимает число как строку n и возвращает число без конечных и стартовых нулей.
Конечные нули - это нули после десятичной точки, которые не влияют на значение (например, последние три нуля в 6.7000 и 6.07000).
Стартовые нули - это нули перед целым числом, которые не влияют на значение (например, первые три нуля в 000427 и 000930).
removeLeadingTrailing("190.000") ➞ "190"
removeLeadingTrailing("00803") ➞ "803"
removeLeadingTrailing("07.1200") ➞ "7.12"
removeLeadingTrailing("90") ➞ "90"
//Вернуть строку.
//Если вы получаете число с .0 в конце, верните целочисленное значение (например, верните «4», а не «4,0»).
//Если число 0, 0,0, 000, 00,00 и т. Д. ... верните «0». */
function removeLeadingTrailing(n){
n.toFixed();
}


//------------------------------------------------------------------
// 1. Создайте функцию, которая принимает два массива, и склеивает массивы вместе. Обязательно после склиевания массива, нужно их отсортировать по возрастанию.

// tuckIn([1, 10], [2, 3, 4, 5, 6, 7, 8, 9]) ➞ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
// tuckIn([15,150], [45, 75, 35]) ➞ [15, 45, 75, 35, 150]
// tuckIn([[5, 6], [1, 2]]) ➞ [1, 2, 5, 6]]

//3. Напишите функцию для замены всех экземпляров символа s1 на символ s2 и наоборот.

// doubleSwap( "aabbccc", "a", "b") ➞ "bbaaccc"
// doubleSwap("random w#rds writt&n h&r&", "#", "&") ➞ "random w&rds writt#n h#r#"
// doubleSwap("128 895 556 788 999", "8", "9") ➞ "129 985 556 799 888"


//4. Напишите функцию, которая возвращает массив строк, отсортированных по длине в порядке возрастания.

// sortByLength(["a", "ccc", "dddd", "bb"]) ➞ ["a", "bb", "ccc", "dddd"]
// sortByLength(["apple", "pie", "shortcake"]) ➞ ["pie", "apple", "shortcake"]
// sortByLength(["may", "april", "september", "august"]) ➞ ["may", "april", "august", "september"]
// sortByLength([]) ➞ []

//Строки будут иметь уникальную длину, поэтому не беспокойтесь о сравнении двух строк одинаковой длины.
//Вернуть пустой массив, если входной массив пуст
